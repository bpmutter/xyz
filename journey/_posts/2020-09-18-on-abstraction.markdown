---
layout: post
title:  "On Abstraction"
date:   2020-09-18 14:05:11 +0900
category: journey
---

The idea of things being abstracted away is at the core of how we make sense and interact with the world around us. 

For example, if I were to turn on the TV in my parent's livingroom (which I certainly find myself doing a lot during this indefinite quarantine), I wouldn't exactly 'hack' into the hardware of the television just to manipulate it to flip on the channel I want to view; that would be rather inefficient and would instead push me towards a less cognitively-demanding pastime. 

Alas, a remote controller exists to free me from such nuisance and this device has certain all-too-familiar features: the big red circular button occupying the top-left corner, with the imprint of the on/off symbol, and the bidirectional arrows that manipulate the output volume, for example. 

What this means is that, wherever I am in the world (outside of my parent's livingroom), I can trust that I wouldn't be totally lost browsing the local channel network through intuition. 

Now, behind the creation of any remote is a team of engineers who essentially 'make the magic happen', outside of our plain sight, so that we, the average-joe users, can trust that we have full control of the TV without being experts in electrical engineering ourselves. 

And, within this team, there would very likely be a division of engineers working on the visual and tactile layout (also known as UI/UX, or the 'front-end'), and a separate one working on the wirings and machinery (or the 'back-end') enclosed within the plastic container.

Unbeknownst to our plain reality, the front-end and the back-end are integrated like two peas in a pod, resulting in the remote ultimately communicating with the the TV itself in order to provide that bridge between our physical input and graphical output on display. I'll talk about front-end/back-end, full-stack development in another entry. 

The reason I bring up this analogy is because I'm being reminded once again that layers of built-in abstractions, such as this remote, exist because it's simply not intuitive for the average person to try to confront abstractions by delving into the core of things. 

After all, every piece of advanced technology is engineered with the average-joe in mind, so that there would be the proverbial remote for every gadget or device that is introduced to us, the end-users. 

Even for computer programmers (who are often the ones building these abstraction tools in this digital era), abstractions such as SDKs and APIs allow them to make life easier in very tangible ways. 

I'm writing about abstractions because I find myself thinking about this concept a lot, as I am trying to get a better sense of how software development works at its core. 

I know that programming, or writing code for that matter, is just a another layer of abstraction that, depending on the language at use (compiler/assembly, etc), you're still pardoned from writing, say, machine code since computer scientists have built an additional layer so that we don't have to express ourselves in binary (0s and 1s) to interact with our local machines. 

Now, having to spend an awful lot of time on web development since taking on the development of this platform jinyoung.xyz, I have been tempted to use popular frameworks and templates that would make my life easier and 'get the job done' quicker (or nicer, even) than I would by building a website from scratch. 

The popular frameworks would miraculously make the HTML elements style responsively on multiple device dimensions, and savvy developers know that the offerings of these shiny web technologies go beyond just that. 

I'm writing to remind myself that the decision to forgo these frameworks has been a fairly deliberate and philosophical one. 

I'm building jinyoung.xyz my way, with my very limited (yet expanding) knowledge because I know that these abstractions, in my humble opinion, would do more to stymie my growing domain knowledge than to support my long-term goal:

which is to see myself become that expert.  

Until then, I will continue to put in the ridonculous number of commits to confront and poke holes in my front-end knowledge. 44 commits/day (on Sept 16th) is my PB so far.

And hopefully things will start to make a lot more sense soon. :)   


